// frontend/lib/icp-agent.ts - Updated with signature validation toggle

import { Actor, HttpAgent, Identity } from '@dfinity/agent';
import { AuthClient } from '@dfinity/auth-client';
import { Principal } from '@dfinity/principal';
import { mockAuthClient, createMockUserManagementActor, ENABLE_MOCK_AUTH } from './mock-auth';

// Import IDL definitions (these will be generated by DFX)
let userManagementIdl: any;
let walletIdl: any;
let marketplaceIdl: any;
let escrowIdl: any;
let aiInsightsIdl: any;

// Try to import declarations, fallback to mock if not available
try {
  userManagementIdl = require('../declarations/user_management').idlFactory;
  walletIdl = require('../declarations/wallet').idlFactory;
  marketplaceIdl = require('../declarations/marketplace').idlFactory;
  escrowIdl = require('../declarations/escrow').idlFactory;
  aiInsightsIdl = require('../declarations/ai_insights').idlFactory;
} catch (error) {
  console.warn('Warning: Could not import canister declarations. Using mock mode.');
  console.log('To fix this, run: dfx generate && move declarations to frontend/declarations/');
}

// Canister IDs from environment variables
const USER_MANAGEMENT_CANISTER_ID =
  process.env.NEXT_PUBLIC_USER_MANAGEMENT_CANISTER_ID || 'uzt4z-lp777-77774-qaabq-cai';
const WALLET_CANISTER_ID =
  process.env.NEXT_PUBLIC_WALLET_CANISTER_ID || 'umunu-kh777-77774-qaaca-cai';
const MARKETPLACE_CANISTER_ID =
  process.env.NEXT_PUBLIC_MARKETPLACE_CANISTER_ID || 'ulvla-h7777-77774-qaacq-cai';
const ESCROW_CANISTER_ID =
  process.env.NEXT_PUBLIC_ESCROW_CANISTER_ID || 'ucwa4-rx777-77774-qaada-cai';
const AI_INSIGHTS_CANISTER_ID =
  process.env.NEXT_PUBLIC_AI_INSIGHTS_CANISTER_ID || 'ufxgi-4p777-77774-qaadq-cai';

// Host configuration
const HOST = process.env.NEXT_PUBLIC_IC_HOST || 'http://localhost:4943';

// CRITICAL: Signature validation toggle
const DISABLE_SIGNATURE_VALIDATION =
  process.env.NEXT_PUBLIC_DISABLE_SIGNATURE_VALIDATION === 'true' ||
  process.env.NODE_ENV === 'development';

// Internet Identity configuration - use mainnet for better reliability
const INTERNET_IDENTITY_URL = 'https://identity.ic0.app';

// NFID configuration
const NFID_URL = process.env.NEXT_PUBLIC_NFID_URL || 'https://nfid.one/authenticate';

// Check if we should use mock mode
const USE_MOCK_MODE = ENABLE_MOCK_AUTH || !userManagementIdl;

console.log('ICP Agent Configuration:');
console.log('HOST:', HOST);
console.log('INTERNET_IDENTITY_URL:', INTERNET_IDENTITY_URL);
console.log('USER_MANAGEMENT_CANISTER_ID:', USER_MANAGEMENT_CANISTER_ID);
console.log('USE_MOCK_MODE:', USE_MOCK_MODE);
console.log('DISABLE_SIGNATURE_VALIDATION:', DISABLE_SIGNATURE_VALIDATION);

export interface ICPActor {
  userManagement: any;
  wallet: any;
  marketplace: any;
  escrow: any;
  aiInsights: any;
}

class ICPAgentManager {
  private authClient: AuthClient | null = null;
  private agent: HttpAgent | null = null;
  private actors: ICPActor | null = null;
  private identity: Identity | null = null;
  private useMockMode: boolean = USE_MOCK_MODE;

  // Initialize the auth client
  async init(): Promise<void> {
    try {
      console.log('Initializing ICP Agent...');

      if (this.useMockMode) {
        console.log('Running in MOCK MODE for development');
        await this.createMockActors();
        return;
      }

      this.authClient = await AuthClient.create({
        idleOptions: {
          idleTimeout: 1000 * 60 * 30, // 30 minutes
          disableDefaultIdleCallback: true,
        },
      });

      if (await this.authClient.isAuthenticated()) {
        console.log('User already authenticated');
        this.identity = this.authClient.getIdentity();
        await this.createAgent();
        await this.createActors();
      } else {
        console.log('User not authenticated');
      }
    } catch (error) {
      console.error('Failed to initialize ICP agent:', error);
      console.log('Falling back to mock mode');
      this.useMockMode = true;
      await this.createMockActors();
    }
  }

  // Create mock actors for development
  private async createMockActors(): Promise<void> {
    console.log('Creating mock actors for development...');

    this.actors = {
      userManagement: createMockUserManagementActor(),
      wallet: { healthCheck: async () => ({ status: 'healthy', timestamp: BigInt(Date.now()) }) },
      marketplace: {
        healthCheck: async () => ({ status: 'healthy', timestamp: BigInt(Date.now()) }),
      },
      escrow: { healthCheck: async () => ({ status: 'healthy', timestamp: BigInt(Date.now()) }) },
      aiInsights: {
        healthCheck: async () => ({ status: 'healthy', timestamp: BigInt(Date.now()) }),
      },
    };

    console.log('Mock actors created successfully');
  }

  // Create HTTP agent with optional signature validation bypass
  private async createAgent(): Promise<void> {
    if (!this.identity) {
      throw new Error('No identity available');
    }

    console.log('Creating HTTP agent with host:', HOST);

    // Agent configuration with signature validation control
    const agentOptions: any = {
      host: HOST,
      identity: this.identity,
    };

    // CRITICAL: Completely disable signature verification in development
    if (DISABLE_SIGNATURE_VALIDATION) {
      console.log('ðŸš¨ DEVELOPMENT MODE: Disabling ALL signature validation');
      agentOptions.verifyQuerySignatures = false;
      agentOptions.disableNonce = true;
      agentOptions.retryTimes = 0; // Don't retry on signature failures
    }

    this.agent = new HttpAgent(agentOptions);

    // Override the agent's call method to suppress signature validation errors in dev
    if (DISABLE_SIGNATURE_VALIDATION) {
      const originalCall = this.agent.call.bind(this.agent);
      this.agent.call = async (canisterId: any, options: any) => {
        try {
          return await originalCall(canisterId, options);
        } catch (error: any) {
          // Suppress signature validation errors in development
          if (
            error?.message?.includes('Invalid delegation') ||
            error?.message?.includes('signature could not be verified') ||
            error?.message?.includes('Invalid canister signature')
          ) {
            console.log('ðŸ”• Suppressed signature validation error in development mode');
            // Return a mock error response instead of throwing
            throw new Error('User not found in development mode - this is expected for new users');
          }
          throw error;
        }
      };
    }

    // Fetch root key for local development
    if (process.env.NODE_ENV !== 'production') {
      try {
        await this.agent.fetchRootKey();
        console.log('Root key fetched for local development');
      } catch (error) {
        console.warn('Failed to fetch root key:', error);
      }
    }
  }

  // Create actor instances for all canisters
  private async createActors(): Promise<void> {
    if (!this.agent || !userManagementIdl) {
      throw new Error('No agent or IDL available');
    }

    try {
      console.log('Creating canister actors...');

      // Actor creation options with signature validation control
      const createActorOptions = {
        agent: this.agent,
      };

      // CRITICAL: Add query signature verification control
      if (DISABLE_SIGNATURE_VALIDATION) {
        (createActorOptions as any).queryVerificationDisabled = true;
      }

      this.actors = {
        userManagement: Actor.createActor(userManagementIdl, {
          ...createActorOptions,
          canisterId: USER_MANAGEMENT_CANISTER_ID,
        }),
        wallet: Actor.createActor(walletIdl, {
          ...createActorOptions,
          canisterId: WALLET_CANISTER_ID,
        }),
        marketplace: Actor.createActor(marketplaceIdl, {
          ...createActorOptions,
          canisterId: MARKETPLACE_CANISTER_ID,
        }),
        escrow: Actor.createActor(escrowIdl, {
          ...createActorOptions,
          canisterId: ESCROW_CANISTER_ID,
        }),
        aiInsights: Actor.createActor(aiInsightsIdl, {
          ...createActorOptions,
          canisterId: AI_INSIGHTS_CANISTER_ID,
        }),
      };

      console.log('All canister actors created successfully');
    } catch (error) {
      console.error('Failed to create actors:', error);
      throw new Error('Failed to create canister actors');
    }
  }

  // Authenticate with Internet Identity
  async authenticateWithII(): Promise<boolean> {
    if (this.useMockMode) {
      console.log('Mock authentication with Internet Identity');
      return await mockAuthClient.login('internet-identity');
    }

    if (!this.authClient) {
      await this.init();
    }

    console.log('Starting Internet Identity authentication...');
    console.log('Using Identity Provider:', INTERNET_IDENTITY_URL);

    return new Promise((resolve, reject) => {
      this.authClient!.login({
        identityProvider: INTERNET_IDENTITY_URL,
        maxTimeToLive: BigInt(7 * 24 * 60 * 60 * 1000 * 1000 * 1000), // 7 days
        onSuccess: async () => {
          try {
            console.log('Internet Identity authentication successful');
            this.identity = this.authClient!.getIdentity();
            await this.createAgent();
            await this.createActors();
            resolve(true);
          } catch (error) {
            console.error('Post-authentication setup failed:', error);
            reject(error);
          }
        },
        onError: (error) => {
          console.error('Internet Identity authentication failed:', error);
          reject(new Error('Authentication failed'));
        },
      });
    });
  }

  // Authenticate with NFID
  async authenticateWithNFID(): Promise<boolean> {
    if (this.useMockMode) {
      console.log('Mock authentication with NFID');
      return await mockAuthClient.login('nfid');
    }

    if (!this.authClient) {
      await this.init();
    }

    console.log('Starting NFID authentication...');
    console.log('Using NFID URL:', NFID_URL);

    return new Promise((resolve, reject) => {
      this.authClient!.login({
        identityProvider: NFID_URL,
        maxTimeToLive: BigInt(7 * 24 * 60 * 60 * 1000 * 1000 * 1000), // 7 days
        windowOpenerFeatures:
          'toolbar=0,location=0,menubar=0,width=500,height=500,left=100,top=100',
        onSuccess: async () => {
          try {
            console.log('NFID authentication successful');
            this.identity = this.authClient!.getIdentity();
            await this.createAgent();
            await this.createActors();
            resolve(true);
          } catch (error) {
            console.error('Post-authentication setup failed:', error);
            reject(error);
          }
        },
        onError: (error) => {
          console.error('NFID authentication failed:', error);
          reject(new Error('NFID authentication failed'));
        },
      });
    });
  }

  // Logout
  async logout(): Promise<void> {
    if (this.useMockMode) {
      await mockAuthClient.logout();
      return;
    }

    if (this.authClient) {
      console.log('Logging out...');
      await this.authClient.logout();
      this.identity = null;
      this.agent = null;
      this.actors = null;
      console.log('Logout successful');
    }
  }

  // Check if authenticated
  async isAuthenticated(): Promise<boolean> {
    if (this.useMockMode) {
      return mockAuthClient.isAuthenticated();
    }

    if (!this.authClient) {
      await this.init();
    }

    const authenticated = this.authClient?.isAuthenticated() || false;
    console.log('Authentication status:', authenticated);
    return authenticated;
  }

  // Get current identity
  getIdentity(): Identity | null {
    return this.identity;
  }

  // Get principal
  getPrincipal(): Principal | null {
    if (this.useMockMode) {
      const principalText = mockAuthClient.getPrincipal();
      return principalText ? Principal.fromText(principalText) : null;
    }
    return this.identity?.getPrincipal() || null;
  }

  // Get actors
  getActors(): ICPActor | null {
    return this.actors;
  }

  // Get specific actor
  getUserManagementActor() {
    return this.actors?.userManagement;
  }

  getWalletActor() {
    return this.actors?.wallet;
  }

  getMarketplaceActor() {
    return this.actors?.marketplace;
  }

  getEscrowActor() {
    return this.actors?.escrow;
  }

  getAIInsightsActor() {
    return this.actors?.aiInsights;
  }

  // Health check
  async healthCheck(): Promise<boolean> {
    try {
      if (!this.actors?.userManagement) {
        console.log('No userManagement actor available for health check');
        return false;
      }

      const result = await this.actors.userManagement.healthCheck();
      const isHealthy = result?.status === 'healthy';
      console.log('Health check result:', isHealthy ? 'healthy' : 'unhealthy');
      return isHealthy;
    } catch (error) {
      console.error('Health check failed:', error);
      return false;
    }
  }
}

// Export singleton instance
export const icpAgent = new ICPAgentManager();

// Helper functions for common operations
export const connectWallet = async (method: 'nfid' | 'internet-identity'): Promise<boolean> => {
  try {
    console.log('Connecting wallet with method:', method);

    if (method === 'nfid') {
      return await icpAgent.authenticateWithNFID();
    } else {
      return await icpAgent.authenticateWithII();
    }
  } catch (error) {
    console.error('Wallet connection failed:', error);
    throw error;
  }
};

export const disconnectWallet = async (): Promise<void> => {
  try {
    await icpAgent.logout();
  } catch (error) {
    console.error('Wallet disconnection failed:', error);
    throw error;
  }
};

export const isWalletConnected = async (): Promise<boolean> => {
  try {
    return await icpAgent.isAuthenticated();
  } catch (error) {
    console.error('Failed to check wallet connection:', error);
    return false;
  }
};

export const getCurrentPrincipal = (): string | null => {
  const principal = icpAgent.getPrincipal();
  return principal ? principal.toText() : null;
};

// Initialize on module load
if (typeof window !== 'undefined') {
  console.log('Initializing ICP agent on client...');
  icpAgent.init().catch((error) => {
    console.error('Failed to initialize ICP agent on load:', error);
  });
}
